# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eyQfTR30SxHoPip6vESzmfL2HqhQS0OG
"""

print("Hello, World!")

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))

from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    result = []

    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)
            queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)

    return result

# Example graph
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(bfs(graph, 0))  # Output: [0, 1, 2, 3, 4]

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    result = [start]

    for neighbor in graph[start]:
        if neighbor not in visited:
            result.extend(dfs(graph, neighbor, visited))

    return result

# Example graph
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(dfs(graph, 0))  # Output: [0, 1, 3, 4, 2]

def idfs(graph, start, goal, max_depth):
    def dfs_with_limit(node, depth):
        if depth == 0:
            return [node] if node == goal else []
        elif depth > 0:
            path = []
            for neighbor in graph[node]:
                if neighbor not in path:
                    result = dfs_with_limit(neighbor, depth-1)
                    if result:
                        path = [node] + result
                        break
            return path
        return []

    for depth in range(max_depth + 1):
        result = dfs_with_limit(start, depth)
        if result:
            return result
    return []

graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(idfs(graph, 0, 3, 3))

import matplotlib.pyplot as plt

x = ['A', 'B', 'C', 'D']
y = [10, 20, 15, 25]

plt.bar(x, y)
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Bar Plot')
plt.show()

import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

plt.scatter(x, y)
plt.xlabel('X Axis')
plt.ylabel('Y Axis')
plt.title('Scatter Plot')
plt.show()

import matplotlib.pyplot as plt

data = [1, 2, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9]

plt.hist(data, bins=5)
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.title('Histogram')
plt.show()

import matplotlib.pyplot as plt

data = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10]

plt.boxplot(data)
plt.ylabel('Value')
plt.title('Box Plot')
plt.show()

import matplotlib.pyplot as plt
import random

x = [0]
y = [0]

for _ in range(100):
    direction = random.choice(['up', 'down', 'left', 'right'])
    if direction == 'up':
        x.append(x[-1])
        y.append(y[-1] + 1)
    elif direction == 'down':
        x.append(x[-1])
        y.append(y[-1] - 1)
    elif direction == 'left':
        x.append(x[-1] - 1)
        y.append(y[-1])
    elif direction == 'right':
        x.append(x[-1] + 1)
        y.append(y[-1])

plt.plot(x, y, marker='o')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Random Movement')
plt.show()

import heapq

def astar(graph, start, goal):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == goal:
            return reconstruct_path(came_from, current)

        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + 1
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                if (f_score[neighbor], neighbor) not in open_set:
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return []

def heuristic(node, goal):
    return abs(node - goal)

def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    return path[::-1]

# Example graph
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 4],
    3: [1],
    4: [1, 2]
}

print(astar(graph, 0, 3))  # Output: [0, 1, 3]